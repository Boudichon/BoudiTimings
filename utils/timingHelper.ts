import moment from "moment";

export interface Command {
  date: Date;
  displayDate: string;
}

export function parseCommands(fullCommands: string) {
  let allDates: Command[] = [];
  var allLines = fullCommands.split('\n');
  var lastManualDate: string = "";

  for (var i = 0; i < allLines.length; i++) {
    const line = allLines[i].trim();

    if (!line || line === "") {
      continue;
    }

    // This part is for the planners that group the attacks by hour.
    // The date is on a header line and the individual commands only have the time.
    // We need to save the date from the header line to use it for the individual commands.
    if (line.startsWith("[b]") || line.startsWith("[s][b]") || line.startsWith("[size=")) {
      const cleanDateLine = cleanLineFromBoldTags(line);
      var possibleDate = cleanDateLine.match(/\d{4}-\d{2}-\d{2}/);
      if (possibleDate !== null) {
        lastManualDate = possibleDate[0];
      }
      continue;
    }

    const cleanLine = cleanLineFromBoldTags(line);
    var result = getTime(cleanLine, lastManualDate);

    if (!result) continue;

    var timing: Command = {
      date: result.date,
      displayDate: result.dateString,
    };

    allDates.push(timing);
  }
  allDates.sort((a, b) => a.date?.getTime() - b.date?.getTime());
  return allDates;
}

enum DateTimeFormat {
  default,
  slash,
  inverted,
}

/* 
  This whole date parsing code is a mess, it was generated by ChatGPT with a few minor manual ajustement.
  I wanted to clean it up, but I no longer remember the specific edge cases of why I need some of these conditions so I will leave it like that.
  It should support most planner formats.
*/

function getTime(line: string, lastDateTime: string) {
  const timeOnlyRegex = /\b\d{2}:\d{2}:\d{2}\b/g; // example: 00:00:00
  const defaultDateTimeRegex = /\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}/g; // example: 2021-01-01 00:00:00 (Devilicious planner and some Red Alert planners)
  const dateTimeWithSlashes = /\d{1,2}\/\d{2}\/\d{4}\s\d{2}:\d{2}:\d{2}/g; // example: 01/01/2021 00:00:00 (Some other Red Alert planners)
  const dateTimeWithInvertedDashes = /\d{2}-\d{2}-\d{4}\s\d{2}:\d{2}:\d{2}/g; // example: 01-01-2021 00:00:00 (fxutility.net planner)

  var times = line.match(timeOnlyRegex);
  var dates = line.match(defaultDateTimeRegex);
  var format = DateTimeFormat.default;
  var commandDateString = null;

  if (!dates || dates.length == 0) {
    dates = line.match(dateTimeWithSlashes);
    if (!!dates?.length) {
      format = DateTimeFormat.slash;
    }
  }

  if (!dates || dates.length == 0) {
    dates = line.match(dateTimeWithInvertedDashes);
    console.log(line, dates);
    if (!!dates?.length) {
      format = DateTimeFormat.inverted;
    }
  }

  if (!times?.length) {
    return null;
  }

  // This code is specific for the Devilicious planner when grouping by hour.
  // When it's grouped by hour, the date is on the header line and the individual commands only have the time. The problem is that the command line can still include a full datetime corresponding to the landing time.
  // So if we only check for a full date, it will give us the landing time instead of the send time. That's why I compare the amount of Dates found versus the amount of Times found.
  // If there is more Date found than time, it means that the send time does not include its date directly in the command line. We need to take the date found in the previous header.
  if (!dates || (times?.length > dates?.length && times?.length < 3)) {
    commandDateString = lastDateTime + " " + times[0];
  } else {
    commandDateString = dates.reduce((a, b) => {
      return new Date(a) < new Date(b) ? a : b;
    });
  }

  if (!commandDateString) return null;

  var parsedDate = null;

  switch (format) {
    case DateTimeFormat.default:
      parsedDate = moment(commandDateString).utcOffset("+01:00", true).toDate();
      break;
    case DateTimeFormat.slash:
      parsedDate = moment(convertSlashDate(commandDateString)).utcOffset("+01:00", true).toDate();
      break;
    case DateTimeFormat.inverted:
      parsedDate = moment(invertDashDate(commandDateString)).utcOffset("+01:00", true).toDate();
      break;
  }

  return { date: parsedDate, dateString: commandDateString };
}

// Remove bold tags from line
function cleanLineFromBoldTags(line: string) {
  return line.replaceAll("[b]", "").replaceAll("[/b]", "");
}

function invertDashDate(datetimeStr: string) {
  const [dateStr, timeStr] = datetimeStr.split(' '); // split date and time
  const [day, month, year] = dateStr.split('-'); // split date into day, month and year
  const formattedDateStr = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`; // format date string as "yyyy-mm-dd"

  const formattedDatetimeStr = `${formattedDateStr} ${timeStr}`; // combine formatted date and time strings
  return formattedDatetimeStr;
}

function convertSlashDate(datetimeStr: string) {
  const [dateStr, timeStr] = datetimeStr.split(' '); // split date and time
  const [day, month, year] = dateStr.split('/'); // split date into day, month and year
  const formattedDateStr = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`; // format date string as "yyyy-mm-dd"

  const formattedDatetimeStr = `${formattedDateStr} ${timeStr}`; // combine formatted date and time strings
  return formattedDatetimeStr;
}